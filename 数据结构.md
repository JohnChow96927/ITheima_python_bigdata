# 数据结构

## I. 什么是数据结构

数据存储于计算机的内存中, 内存如下图所示, 形似排成1列的箱子, 一个箱子里存储1个数据.

![1648174326332](assets/1648174326332.png)

数据存储于内存时, 决定了数据顺序和位置关系的便是"数据结构"

### 电话簿的数据结构

#### 例① 按从上往下获取顺序添加

想找一个联系人, 只能按照顺序从上往下找, 当号码多的时候就不那么容易了

#### 例② 按姓名的拼音顺序排列

通过姓名的拼音首字母就能推测出该数据的大致位置, 但是当要插入新联系人时, 需要从下往上执行"将本行的内容写进下一行, 然后清除本行内容"的操作, 如果数据量大, 将很复杂.

顺序添加添加简单, 查询复杂

拼音顺序排列查询简单, 添加复杂

#### 将获取顺序于拼音顺序结合

分别使用不同的表存储不同的拼音首字母, 然后将同一张表中的数据按照获取顺序进行排列

这样一来, 在添加新数据时, 直接将数据加入到相应表中的末尾就可以了, 而查询数据时, 也只需要到其对应的表中去查找即可

因为各个表中存储的数据依旧是没有规律的, 所以查询时仍需从表头开始找起, 但比查询整个电话簿来说还是要轻松多了

## II. 链表

### 单链表

链表是数据结构之一, 其中的数据呈线性排列. 在链表中, 数据的添加和删除都较为方便, 就是访问比较耗费时间

1. 链表中的每一个数据都有一个"指针", 它指向下一个数据的内存地址

   ![1648175192537](assets/1648175192537.png)

2. 在链表中, 数据一般都是分散存储于内存中的, 无须存储在连续空间里

   ![1648175212147](assets/1648175212147.png)

3. 因为数据是分散的, 所以如果想要访问数据, 只能从第一个数据开始, 顺着指针的指向一一往下访问(顺序访问)直到找到所需的数据

4. 如果需要添加数据, 只需要改变添加位置前后的指针指向就可以, 非常简单

   ![1648213085281](assets/1648213085281.png)

   ![1648213165528](assets/1648213165528.png)

5. 数据的删除也一样, 只要改变指针的指向就可以, 比如删除yellow

   ![1648213355198](assets/1648213355198.png)

   ![1648213406455](assets/1648213406455.png)

### 时间复杂度

如果目标在链表最后的话, 访问需要的时间就是O(n), 添加与删除需要的时间复杂度都是O(1)

### 循环链表

在链表尾部使用指针, 并且让它指向链表头部的数据, 将链表变成环形. 循环链表没有头和尾的概念. 想要**保存数量固定的最新数据**时通常会使用这种链表

![1648218569809](assets/1648218569809.png)

### 双向链表

可以把每个数据的指针设定为两个, 并且让它们分别指向前后的数据. 双向链表不仅可以从前往后, 还可以从后往前遍历数据.

#### 缺点

1. 指针数的增加会导致存储空间需求增加
2. 增加和删除数据时需要改变更多指针的指向

![1648218669418](assets/1648218669418.png)

## III. 数组

数组也是数据呈线性排列的一种数据结构. 数组中, 访问数据十分简单, 而添加和删除数据比较耗功夫.

数组下标从0开始计算

![1648353966832](assets/1648353966832.png)

数组按顺序存储在内存的连续空间内, 所以每个数据的内存地址(在内存上的位置)都可以通过数组下标算出, 也可以借此直接访问目标数据(**随机访问**)

![1648354010795](assets/1648354010795.png)

在数组中只要指定下标就可以直接访问数据(**随机访问**), 而在链表中只能从头开始查找

![1648354274927](assets/1648354274927.png)

数组的添加或删除操作比链表复杂很多, 首先在数组的末尾确保需要增加的存储空间, 然后为了给新数据腾出位置, 要把已有数据一个个移开

![1648354462840](assets/1648354462840.png)

![1648355201099](assets/1648355201099.png)

![1648355280014](assets/1648355280014.png)

![1648355358899](assets/1648355358899.png)

![1648355371833](assets/1648355371833.png)

### 时间复杂度

访问: O(1), 因为使用随机访问

增加删除: O(n)

![1648355682069](assets/1648355682069.png)

## IV. 栈

栈也是一种数据呈线性排列的数据结构, 不过在这种结构中, 我们只能访问最新添加的数据. 栈就像一摞书, 拿到新书时我们会把它放在书堆的最上面, 取书时也只能从最上面的新书开始取

入栈(**push**)出栈(**pop**)

![1648355824710](assets/1648355824710.png)

![1648355856011](assets/1648355856011.png)

像栈这种最后添加的数据最先被取出, 即"**后进先出**"的结构, **Last In First Out(LIFO)**

与链表和数组一样, 栈的数据也是线性排列的, 但在栈中, 添加和删除数据的操作只能在一端进行, 访问数据也只能访问到顶端的数据. 想要访问中间的数据时, 就必须通过出栈操作将目标数据移到栈顶才行

只需要访问最新数据时, 使用它就比较方便了.

比如，规定（AB（C（DE）F）（G（（H）I J）K））这一串字符中括号的处理方式如下：首先从左边开始读取字符，读到左括号就将其入栈，读到右括号就将栈顶的左括号出栈。此时，出栈的左括号便与当前读取的右括号相匹配。通过这种处理方式，我们就能得知配对括号的具体位置。

## V. 队列

队列中的数据也呈线性排列. 虽然与栈有些相似, 但队列中添加和删除数据的操作分别是在两端进行的. 就和"队列"这个名字一样, 把它想象成排成一队的人更容易理解. 在队列中, 处理总是从第一名开始往后进行, 而新来的人只能排在队尾.

![1648371542013](assets/1648371542013.png)

![1648371576023](assets/1648371576023.png)

像队列这种最先进去的数据最先被取来, 即"**先进先出**"的结构, 称之为**First In First Out**, 简称**FIFO**.

与栈类似, 队列中可以操作数据的位置也有一定的限制. 在栈中, 数据的添加和删除都在同一端进行, 而在队列中则分别是在两端进行. 队列也不能直接访问位于中间的数据, 必须通过出队操作将数据变成首位后才可以访问

"先来的数据先处理"是一种很常见的思路, 所以队列的应用范围非常广泛."广度优先搜索"

## VI. 哈希表

哈希表存储的是由键(key)和值(value)组成的数据.

![1648372067500](assets/1648372067500.png)

提示: 一般来说, 可以把键当成数据的标识符, 把值当成数据的内容

![1648372221012](assets/1648372221012.png)

![1648372371444](assets/1648372371444.png)

![1648372635533](assets/1648372635533.png)

![1648373116634](assets/1648373116634.png)

![1648373836951](assets/1648373836951.png)

![1648373903734](assets/1648373903734.png)

在哈希表中, 我们可以利用哈希函数快速访问到数组中的目标数据. 如果发生哈希冲突, 就使用链表进行存储. 这样一来, 不管数据量为多少, 我们都能够灵活应对.

如果数组的空间太小, 使用哈希表的时候就容易发生冲突, 线性查找的使用频率也会更高; 反过来, 如果数组的空间太大, 就会出现很多空箱子, 造成内存的浪费. 因此, 给数组设定合适的空间非常重要.

- **补充说明**:

  在存储数据过程中, 如果发生冲突, 可以利用链表在已有数据的后面插入新数据来解决冲突. 这种方法被称为"**链地址法**".

  除了链地址法外, 还有几种解决冲突的方法, 其中, 应用较为广泛的是"**开放地址法**". 这种方法是指当冲突发生时, 立刻计算出一个候补地址(数组上的位置), 并将数据存进去. 如果仍然有冲突, 便继续计算下一个候补地址, 直到有空地址为止. 可以通过多次使用哈希函数或"线性探测法"等方法计算候补地址

  因为哈希表在数据存储上的灵活性和数据查询上的高效性, 编程语言的关联数组等也常常会使用它

## VII. 堆

堆是一种图的树形结构, 被用于实现"**优先队列(priority queues)**". 优先队列是一种数据结构, 可以自由添加数据, 但取出数据时要从最小值开始按顺序取出. 在堆的树形结构中, 各个顶点被称为"节点(node)", 数据就存储在这些节点中

![1648375480218](assets/1648375480218.png)

![1648375666549](assets/1648375666549.png)

![1648375858974](assets/1648375858974.png)

![1648376141909](assets/1648376141909.png)

堆中最顶端的数据始终最小, 所以无论数据量有多少, 取出最小值的时间复杂度都为O(1).

因为取出数据后需要将最后的数据移到最顶端, 然后一边比较它的子节点数据的大小, 一边往下移动, 所以取出数据需要的运行时间和树的高度成正比. 假设数据量为n, 根据堆的形状特点可知树的高度为log2(n), 那么重构树的时间复杂度便为O(log(n))

添加数据也一样, 在堆的最后添加数据后, 数据会一边比较它与父节点数据的大小, 一边往上移动, 直到满足堆的条件为止, 所以添加数据需要的运行时间与树的高度成正比, 也是O(log(n))

如果需要频繁地从管理地数据中取出最小值, 那么使用堆来操作会非常方便.

## VIII. 二叉查找树

二叉查找树(又叫作二叉搜索树或二叉排序树)是一种数据结构, 采用了图的树形结构. 数据存储于二叉查找树的各个节点中

