1. 以下程序输出为:

    ```python
    info = {'name':'班长', 'id':100, 'sex':'f', 'address':'北京'}
    age = info.get('age')
    print(age)
    age=info.get('age',18)
    print(age)
    ```

    正确答案: None 18

    错误解析: 

    ```python
    # get方法语法:
    dict.get(key, default = None)
    # 如果指定的键不存在则返回default指定的默认值, 第4行get中传入第二个参数指定默认值为18, 则返回18
    ```

2. 执行以下程序, 输出结果为:

    ```python
    a = [['1','2'] for i in range(2)]
    
    b = [['1','2']] * 2
    
    a[0][1] = '3'
    
    b[0][0] = '4'
    
    print(a,b) 
    ```

    正确答案: [['1', '3'], ['1', '2']] [['4', '2'], ['4', '2']]

    错误解析:

    ```python
    a = [['1','2'] for i in range(2)]	# 深复制
    
    b = [['1','2']] * 2	# id(b[0]) == id(b[1]), 嵌套列表乘法得到的每个项都是引用
    ```

3. 对于以下代码, 描述正确的是:

    ```python
    list = ['1', '2', '3', '4', '5']
    print list[10:]
    ```

    正确答案: 输出[]

    错误解析:

    切片不受内建类型的限制

4. 执行以下程序, 输出结果为

    ```python
    def outer(fn):
        print('outer')
        def inner():
            print('inner')
            return fn
        return inner
    
    
    @outer
    def fun():
        print('fun')
    ```

    正确答案: outer

    错误解析: 装饰器会在被装饰的函数定义之后立即执行

5. Mysql中表student_table(id,name,birth,sex)，插入如下记录：

    ```mysql
    ('1003' , '' , '2000-01-01' , '男');
    ('1004' , '张三' , '2000-08-06' , '男');
    ('1005' , NULL , '2001-12-01' , '女');
    ('1006' , '张三' , '2000-08-06' , '女');
    ('1007' , ‘王五’ , '2001-12-01' , '男');
    ('1008' , '李四' , NULL, '女');
    ('1009' , '李四' , NULL, '男');
    ('1010' , '李四' , '2001-12-01', '女');
    ```

    执行

    ```mysql
    select t1.*,t2.*
    from (
    select * from student_table where sex = '男' ) t1 
    inner  join 
    (select * from student_table where sex = '女')t2 
    on t1.birth = t2.birth and t1.name = t2.name ; 
    ```

    的结果行数是:

    正确答案: 1

    错误解析: 在SQL中, NULL与任何值比较永不为真

6. ![image-20220110202553228](image-20220110202553228.png)

    解析: fromkeys(seq=a, value=b)方法以a中元素做字典的键, b做所有键对应的初始值

7. ![image-20220110202850342](image-20220110202850342.png)

    错误解析: upper()方法先将strs中所有字符转为大写'ABCD12EFG', 然后title()方法再将strs中每个单词首字母转为大写, 其余字母转为小写, 得'Abcd12Efg'

8. ![image-20220110203101902](image-20220110203101902.png)

    错误解析: python中主要存在4中命名方式

     1. object: 公用方法

     2. _object: 半保护

        被看作是“protect”，只有类对象和子类对象自己能访问到这些变量, 在模块或类外不可以使用，不能用’from module import *’导入。

        \#_\_object 是为了避免与子类的方法名称冲突， 对于该标识符描述的方法，父类的方法不能轻易地被子类的方法覆盖，他们的名字实际上是\_classname\_\_methodname。

     3. __object: 全私有, 全保护, 只有类对象自己能访问, 子类对象也不能访问, 需要用类方法获取和修改

     4. `__object__`: 内建方法, 用户不要这样定义

9. ![image-20220111210631072](imgs/image-20220111210631072.png)

    错误解析: left join即使没有匹配, 左表t1的内容也会被查询出来, 故结果为[张三, 李四], 此题应用inner join

10. ![image-20220111212818974](imgs/image-20220111212818974.png)

  错误解析: 对于可变数据类型list, 作为函数形参赋默认值时, 每次只在第一次执行赋值,

  对于不可变数据类型tuple, 作为函数形参赋默认值的时候, 每次函数调用都会执行, 相当于每次都清空

11. ![image-20220112100129873](imgs/image-20220112100129873.png)

     错误解析:

     - 共享锁(S锁): 又称为读锁, 若事务T对数据对象A上S锁, 则事务T只能读A; 其他事务只能再对A加S锁, 而不能加X锁(排他锁), 直到事务T释放A上的S锁. 确保了其他事务在T释放A上的S锁之前只能读A而不能修改A.
     - 排他锁(X锁): 又称为写锁, 独占锁, 若事务T对数据对象A加X锁, 则只允许T读取和修改A, 其他任何事务都不能再对A加任何类型的锁(体现排他性), 直到T释放A上的锁. 确保了其他事务在T释放A上的锁之前不能再读取和修改A.
     - 更新锁: 为了解决死锁, 引入更新锁, 更新锁的意思是: "我现在只想读, 你们别人也可以读, 但我将来可能会做更新操作, 我已经获取了从共享锁(读锁)到排他锁的资格". 一个事务只能有一个更新锁获此资格.
     - 死锁: 死锁是一种现象, 即进程A等待B释放资源, B也在等待A释放资源, 互相等待造成两个进程都无法继续下去.
     - 架构锁: 不存在这种东西!

12. ![image-20220112105905822](imgs/image-20220112105905822.png)

     - ##### 错误解析: 当实例对象做P[key]运算时, 就会调用类中的`__getitem__()`方法

13. ![image-20220113232138990](imgs/image-20220113232138990.png)

     错误解析:

     HAVING是在分组后对数据进行过滤, WHERE是在分组前对数据进行过滤

     HAVING后可以使用聚合函数, WHERE后不可使用聚合函数

     所以, HAVING子句必须与GROUP BY子句同时使用, 不能单独使用

14. ![image-20220115172247293](imgs/image-20220115172247293.png)

     错误解析: find()返回第一个找到的位置索引, 找不到则返回-1, index()返回第一个找到的位置索引, 找不到则报错

15. ![image-20220115172549277](imgs/image-20220115172549277.png)

16. 

