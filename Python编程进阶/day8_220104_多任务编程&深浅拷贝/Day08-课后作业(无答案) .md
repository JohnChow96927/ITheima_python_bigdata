[TOC]

## Day08-多任务编程vs深浅拷贝

### 今日课程学习目标

```shell
掌握多任务编程中进程和线程的概念
熟悉python中多进程和多线程的使用
常握深拷贝和浅拷贝的区别
```

### 今日课程内容大纲

```shell
# 1. 多任务编程
	多任务的基本概念
	进程：资源分配的基本单位
		python中多进程的基本使用
		主进程和子进程
		进程执行带有参数的任务
		进程使用的2个注意点
		守护进程和终止子进程
	线程：CPU调度的基本单位
		python中多线程的基本使用
		线程执行带有参数的任务
		线程使用的3个注意点
		守护线程的设置
		线程资源共享问题与解决：线程join等待和互斥锁
# 2. 深拷贝和浅拷贝
	深拷贝
	浅拷贝
```

### 基础概念题

#### 1. 简述什么是并发？什么是并行？

**参考答案:**

```bash
# 你的答案
并发是两个任务快速交替运行
并行是两个任务同时运行
```



#### 2. 说一下什么是进程？什么是线程？以及两者的区别？	

**参考答案:**

```shell
# 你的答案
进程是计算机分配资源的基本单位
线程是CPU调度的基本单位
线程依附进程而存在, 进程开销大但可以使用多核资源线程开销小但不能使用多核资源(仅在Python中)
进程不共享全局变量, 线程共享全局变量但要注意资源竞争问题
多进程开发比多线程开发稳定性要强
一个进程默认提供一条主线程, 进程可以创建多个线程
```



#### 3. 什么是互斥锁? 说出互斥锁的应用场景

**参考答案:**

```bash
# 你的答案
互斥锁是避免多线程访问共享资源时冲突使用的工具, 先得到互斥锁的线程先执行代码, 执行完释放互斥锁, 其他线程再竞争
互斥锁用来保证同一时刻只能有一个线程访问共享资源, 保证了共享数据操作的完整性
```



#### 4. 什么是浅拷贝？什么是深拷贝？

**参考答案**：

```bash
# 你的答案
浅拷贝是copy.copy()
深拷贝是copy.deepcopy()
浅拷贝会对容器第一层进行检查, 若是可变容器类型, 则为此层开辟新的内存空间进行拷贝, 若是不可变容器类型则等于赋值=操作
深拷贝会对容器每一层进行检查, 若检查到的层为可变容器类型则为当前层开辟新的内存空间进行拷贝, 若检查到的层为不可变容器类型则等于赋值=操作
```



### 代码练习题

#### 1. 完成课上的代码【3遍】



### Python基础题

#### 1. 题目1

**题目说明**：

有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？

**参考答案**：

```python
# 你的答案
result = []
for i in range(1, 5):
    for j in range(1, 5):
        for k in range(1, 5):
            if i != j and j !=k and k != i:
                result.append(100 * i + 10 * j + k)
print(result)
```



#### 2. 题目2

**题目说明**：

企业发放的奖金根据利润提成。

* 利润(I)低于或等于10万元时，奖金可提10%；
* 利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；
* 20万到40万之间时，高于20万元的部分，可提成5%；
* 40万到60万之间时高于40万元的部分，可提成3%；
* 60万到100万之间时，高于60万元的部分，可提成1.5%；
* 高于100万元时，超过100万元的部分按1%提成；

从键盘输入当月利润I，求应发放奖金总数？

**参考答案**：

```python
# 你的答案
def bonus(l):
    # 保存奖金
    fit = 0

    # arr中的每个数字表示利润的档次(万元)
    arr = (100, 60, 40, 20, 10, 0)
    # rat中的每个数字表示超过该档次的利润，可提奖金的比例
    rat = (0.01, 0.015, 0.03, 0.05, 0.075, 0.1)

    # 35
    for i, money in enumerate(arr):
        # money：100
        # money：60
        # money：40
        # money：20
        # money：10
        # money：0
        if l > money:
            fit += (l - money) * rat[i]
            # pro = 20
            # pro = 10
            # pro = 0
            l = money

    print('奖金（元）：', fit * 10000)
```
