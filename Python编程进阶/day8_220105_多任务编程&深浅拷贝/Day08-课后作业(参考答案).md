[TOC]

## Day08-多任务编程vs深浅拷贝

### 今日课程学习目标

```shell
掌握多任务编程中进程和线程的概念
熟悉python中多进程和多线程的使用
常握深拷贝和浅拷贝的区别
```

### 今日课程内容大纲

```shell
# 1. 多任务编程
	多任务的基本概念
	进程：资源分配的基本单位
		python中多进程的基本使用
		主进程和子进程
		进程执行带有参数的任务
		进程使用的2个注意点
		守护进程和终止子进程
	线程：CPU调度的基本单位
		python中多线程的基本使用
		线程执行带有参数的任务
		线程使用的3个注意点
		守护线程的设置
		线程资源共享问题与解决：线程join等待和互斥锁
# 2. 深拷贝和浅拷贝
	深拷贝
	浅拷贝
```

### 基础概念题

#### 1. 简述什么是并发？什么是并行？

**参考答案:**

```
并发: 一个CPU在一段时间内快速交替执行多个任务
并行: 多个CPU，每个CPU在一段时间执行一个任务
```



#### 2. 说一下什么是进程？什么是线程？以及两者的区别？	

**参考答案:**

```shell
区别对比：
1. 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位
2. 线程不能够独立执行，必须依存在进程中
3. 创建进程的资源开销要比创建线程的资源开销要大
4. 进程之间不共享全局变量，线程之间共享全局变量，但是要注意资源竞争的问题
5. 多进程开发比单进程多线程开发稳定性要强

关系对比：
1. 线程是依附在进程里面的，没有进程就没有线程
2. 一个进程默认提供一条线程，进程可以创建多个线程
```



#### 3. 什么是互斥锁? 说出互斥锁的应用场景

**参考答案:**

```
互斥锁: 为保证共享数据操作的完整性, threading模块给我们提供了一个Lock类, 我们把这个类创建的对象对应于一个可称为"互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该共享数据.

互斥锁应用场景: 互斥锁可用于多线程中有可能产生共享数据(如全局变量)竞争的场景.
```



#### 4. 什么是浅拷贝？什么是深拷贝？

**参考答案**：

```
浅拷贝：copy.copy(...)
* 可变容器类型，进行浅拷贝时，只会对第一层数据重新开辟内存，进行拷贝。
* 不可变容器类型，进行浅拷贝时，不会重新开辟内存，等同于=号赋值。

深拷贝：copy.deepcopy(...)
* 可变容器类型，进行深拷贝时，每一层可变数据都会重新开辟内存，进行拷贝。
* 不可变容器类型
  * 简单不可变容器类型，进行深拷贝时，不会重新开辟内存，等同于=号赋值。
  * 嵌套不可变容器类型，进行深拷贝时，如果内层有可变类型时，则会重新开辟内存空间，进行拷贝。
```



### 代码练习题

#### 1. 完成课上的代码【3遍】



### Python基础题

#### 1. 题目1

**题目说明**：

有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？

**参考答案**：

```python
# 第一层循环控制百位的数字
for a in range(1, 5):
    # 第二层循环控制十位的数字
    for b in range(1, 5):
        # 第三层循环控制个位的数字
        for c in range(1, 5):
            # 百位、十位、个位数字不能相同
            if a != b and b != c and a != c:
                print(a, b, c)
```

#### 2. 题目2

**题目说明**：

企业发放的奖金根据利润提成。

* 利润(I)低于或等于10万元时，奖金可提10%；
* 利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；
* 20万到40万之间时，高于20万元的部分，可提成5%；
* 40万到60万之间时高于40万元的部分，可提成3%；
* 60万到100万之间时，高于60万元的部分，可提成1.5%；
* 高于100万元时，超过100万元的部分按1%提成；

从键盘输入当月利润I，求应发放奖金总数？

**参考答案**：

方式1：

```python
# 接收用户输入净利润
pro = float(input('净利润（万元）：'))
# 保存奖金
fit = 0

if 0 <= pro <= 10:
    fit = pro * 0.1
elif 10 < pro <= 20:
    fit = 10 * 0.1 + (pro - 10) * 0.075
elif 20 < pro <= 40:
    fit = 10 * 0.1 + 10 * 0.075 + (pro - 20) * 0.05
elif 40 < pro <= 60:
    fit = 10 * 0.1 + 10 * 0.075 + 20 * 0.05 + (pro - 40) * 0.03
elif 60 < pro <= 100:
    fit = 10 * 0.1 + 10 * 0.075 + 20 * 0.05 + 20 * 0.03 + (pro - 60) * 0.015
else:
    fit = 10 * 0.1 + 10 * 0.075 + 20 * 0.05 + 20 * 0.03 + 40 * 0.015 + (pro - 100) * 0.01

print('奖金（元）：', fit * 10000)
```

方式2：

```python
# 接收用户输入净利润
pro = float(input('净利润（万元）：'))
# 保存奖金
fit = 0

# arr中的每个数字表示利润的档次(万元)
arr = (100, 60, 40, 20, 10, 0)
# rat中的每个数字表示超过该档次的利润，可提奖金的比例
rat = (0.01, 0.015, 0.03, 0.05, 0.075, 0.1)

# 35
for i, money in enumerate(arr):
    # money：100
    # money：60
    # money：40
    # money：20
    # money：10
    # money：0
    if pro > money:
        fit += (pro - money) * rat[i]
        # pro = 20
        # pro = 10
        # pro = 0
        pro = money

print('奖金（元）：', fit * 10000)
```
