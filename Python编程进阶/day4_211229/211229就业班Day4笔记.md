# 1. 闭包

- ##### 在**Python**中, **万物皆对象**

- ##### 定义函数的时候就开辟空间加载函数

- ##### 函数的传递就意味着功能的传递

- ##### 闭包的定义: 在函数嵌套的前提下,内部函数使用了外部函数的变量, 并且外部函数返回了内部函数, 这个使用外部函数变量的内部函数称为闭包

- ### **构成闭包的条件:** 

    - ### **在函数嵌套的前提下**

    - ### **内部函数使用外部函数的变量(包括参数)**

    - ### **外部函数返回内部函数**

- ##### 闭包的作用: 可以用来保存函数中的变量,不会随着函数调用而销毁

- ##### 函数不加()可当做变量进行传递,加()就是调用了

# 2. 装饰器

- ##### 抓取异常, 将异常写入到文件中(完整异常traceback.format_exc())

- ##### 装饰器符合开发中的**封闭开放**原则(开闭原则), 对修改是封闭的, 对于拓展是开放的

- ##### 装饰器的基础写法:

    ```python
    def 装饰器名(装饰器修饰的函数):
        def 装饰函数(*args, **kwargs):
            装饰功能代码块
            ...装饰器修饰的函数(*args, **kwargs)...
        return 装饰函数
    
    
    @装饰器名
    def 功能函数(参数):
        功能代码块
    ```

- 运行逻辑: 

    - 调用功能函数时, 将功能函数作为参数传入装饰器中
    - 使用装饰器中的闭包增强功能函数的功能后, 装饰器返回闭包

- 带参数的装饰器: 在函数中嵌入装饰器, 增强装饰器的功能

    ```python
    def 带参数的装饰器名(可选参数):
        def 装饰器名(装饰器修饰的函数):
            def 装饰函数(*args, **kwargs):
                装饰功能代码块
                ...装饰器修饰的函数(*args, **kwargs)...
            return 装饰函数
        return 装饰器名
    
    
    @带参数的装饰器名(可选参数)
    def 功能函数(参数):
        功能代码块
    ```

- 使用functools.wraps()保留原功能函数的名称及说明不被装饰函数覆盖

    ```python
    from functools import wraps
    
    
    def 带参数的装饰器名(可选参数):
        def 装饰器名(功能函数):
            @wraps(功能函数)
            def 装饰函数(*args, **kwargs):
                装饰功能代码块
                ...装饰器修饰的函数(*args, **kwargs)...
            return 装饰函数
        return 装饰器名
    
    
    @带参数的装饰器名(可选参数)
    def 功能函数(参数):
        功能代码块
    ```

    